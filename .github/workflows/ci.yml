# This workflow performs security scanning and code quality analysis
# It includes Trivy for container security and PHPStan for static analysis

name: üõ°Ô∏è Security & Code Quality

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:

permissions:
  contents: read

jobs:
  # Job 1: Escaneo de seguridad (security_scan)
  security_scan:
    permissions:
      contents: read
      security-events: write
      actions: read
    name: üîç Security Scan
    runs-on: ubuntu-latest
    steps:
      - name: ‚¨áÔ∏è Checkout code
        uses: actions/checkout@v4

      # Construcci√≥n y escaneo del Front-end (FE)
      - name: üèóÔ∏è Build Front-end Image (fe-web)
        run: docker build -t fe-web-image -f docker/fe/Dockerfile .

      - name: üîé Scan Front-end Image with Trivy
        uses: aquasecurity/trivy-action@7b7aa264d83dc58691451798b4d117d53d21edfe
        with:
          image-ref: 'fe-web-image'
          format: 'template'
          template: '@/contrib/sarif.tpl'
          output: 'trivy-results-fe.sarif'
          severity: 'CRITICAL,HIGH'

      - name: üì§ Upload Front-end Trivy results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: 'trivy-results-fe.sarif'
          category: trivy-fe-scan 

      # Construcci√≥n y escaneo del Task Worker
      - name: üèóÔ∏è Build Task Worker Image
        run: docker build -t task-worker-image -f docker/worker/Dockerfile-php .

      - name: üîé Scan Task Worker Image with Trivy
        uses: aquasecurity/trivy-action@7b7aa264d83dc58691451798b4d117d53d21edfe
        with:
          image-ref: 'task-worker-image'
          format: 'template'
          template: '@/contrib/sarif.tpl'
          output: 'trivy-results-worker.sarif'
          severity: 'CRITICAL,HIGH'

      - name: üì§ Upload Worker Trivy results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: 'trivy-results-worker.sarif'
          category: trivy-worker-scan 

      - name: ‚úÖ Security Scan Confirmation
        run: echo "üõ°Ô∏è Security scan completed successfully!"
        if: always()

  # Job 2: Calidad de c√≥digo (code_quality)
  code_quality:
    name: üìä Code Quality Analysis
    runs-on: ubuntu-latest
    steps:
      - name: ‚¨áÔ∏è Checkout code
        uses: actions/checkout@v4

      - name: üêò Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.2'
          # Se asegura que la extensi√≥n Redis est√© disponible para el an√°lisis
          extensions: pdo, pdo_pgsql, pgsql, zip, redis 
          coverage: none

      - name: üì¶ Install Composer dependencies
        run: |
          # Install Composer
          curl -sS https://getcomposer.org/installer | php
          php composer.phar install --no-progress --no-scripts

      - name: üîç Run PHPStan on all PHP code
        run: |
          # Run PHPStan using the composer script
          composer phpstan -- --error-format=github

      - name: ‚úÖ Code Quality Confirmation
        run: echo "üìä Code quality analysis completed!"
        if: always()

  # Job 3: Pruebas de integraci√≥n (integration_tests)
  integration_tests:
    name: üß™ Integration Tests
    runs-on: ubuntu-latest
    needs: [security_scan, code_quality]
    
    # Declaraci√≥n de variables de entorno de prueba para Docker Compose
    env:
      PG_HOST: postgres 
      REDIS_HOST: redis 
      PG_DB: app_db
      PG_USER: testuser
      PG_PASSWORD: testpassword
      POSTGRES_USER: testuser
      POSTGRES_PASSWORD: testpassword
      POSTGRES_BI_USER: biuser
      POSTGRES_BI_PASSWORD: bipassword
      MINIO_ROOT_USER: minioadmin
      MINIO_ROOT_PASSWORD: miniopassword
      MARIADB_ROOT_PASSWORD: mariapassword

    steps:
      - name: ‚¨áÔ∏è Checkout code
        uses: actions/checkout@v4

      # PASO CLAVE: Crear el archivo de sanidad (Health Check)
      - name: üõ†Ô∏è Create full health check file (src/fe/index.php)
        run: |
          # 1. Asegurar el directorio
          mkdir -p src/fe
          
          # 2. Escribir el c√≥digo PHP del Health Check
          # Este c√≥digo utiliza las variables de entorno definidas en 'env:' arriba
          cat << 'EOF_PHP' > src/fe/index.php
          <?php
          // Health Check Completo (PostgreSQL y Redis)
          
          // Configuraci√≥n (usa las variables de entorno inyectadas por Docker Compose)
          $PG_HOST = getenv('PG_HOST') ?: 'postgres';
          $PG_PORT = getenv('PG_PORT') ?: '5432';
          $PG_DB = getenv('PG_DB') ?: 'app_db';
          $PG_USER = getenv('PG_USER') ?: 'testuser';
          $PG_PASSWORD = getenv('PG_PASSWORD') ?: 'testpassword';
          $REDIS_HOST = getenv('REDIS_HOST') ?: 'redis';
          $REDIS_PORT = getenv('REDIS_PORT') ?: '6379';

          header('Content-Type: application/json');
          $status = ['application' => ['status' => 'OK', 'timestamp' => date('Y-m-d H:i:s'), 'server_info' => gethostname()], 'services' => []];
          $errors = [];

          // 1. Check PostgreSQL
          try {
              $dsn = "pgsql:host=$PG_HOST;port=$PG_PORT;dbname=$PG_DB";
              $pdo = new PDO($dsn, $PG_USER, $PG_PASSWORD, [PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION]);
              $pdo->query('SELECT 1');
              $status['services']['postgres'] = ['status' => 'OK', 'details' => 'Database connection successful.'];
          } catch (Exception $e) {
              $status['services']['postgres'] = ['status' => 'FAIL', 'details' => 'Connection failed: ' . $e->getMessage()];
              $errors[] = 'PostgreSQL check failed.';
          }

          // 2. Check Redis
          try {
              $redis = new Redis();
              if (@$redis->connect($REDIS_HOST, $REDIS_PORT) && @$redis->ping() === '+PONG') {
                  $status['services']['redis'] = ['status' => 'OK', 'details' => 'Redis connection successful.'];
              } else {
                  throw new \Exception('Connection failed to Redis host/port or PING failed.');
              }
          } catch (Exception $e) {
              $status['services']['redis'] = ['status' => 'FAIL', 'details' => 'Connection failed: ' . $e->getMessage()];
              $errors[] = 'Redis check failed.';
          }
          
          // 3. Respuesta Final
          if (!empty($errors)) {
              http_response_code(500);
              $status['application']['status'] = 'FAIL';
              $status['application']['errors'] = $errors;
          } else {
              http_response_code(200);
          }

          echo json_encode($status, JSON_PRETTY_PRINT);
          exit;
          EOF_PHP
        
        echo "Health-check file (src/fe/index.php) created successfully."

      - name: üê≥ Start Docker Compose (with build)
        # Iniciar todos los servicios.
        run: |
          docker compose up --build -d
          # Esperar un breve tiempo inicial para la inicializaci√≥n
          sleep 5

      # Bucle de reintento robusto para esperar a que el sistema est√© sano.
      - name: üîç Check service health with extended retry (Port 80)
        run: |
          MAX_RETRIES=30 # Aumentado el n√∫mero de reintentos a 30 (150 segundos)
          DELAY=5        # Delay de 5 segundos
          CURL_TARGET="http://localhost:80/index.php" 
          
          echo "Iniciando bucle de comprobaci√≥n de salud para $CURL_TARGET..."

          for i in $(seq 1 $MAX_RETRIES); do
            echo "Intento $i/$MAX_RETRIES..."
            
            # Usamos -s (silencioso), -o /dev/null (descarta el cuerpo), -w %{http_code} (solo imprime el c√≥digo HTTP)
            RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" $CURL_TARGET)
            
            # Si se recibe HTTP 200, la prueba de integraci√≥n es exitosa
            if [ "$RESPONSE" = "200" ]; then
              echo "‚úÖ El servicio est√° completamente operativo y sano (HTTP 200 recibido)!"
              # Opcional: Mostrar el JSON de salud para confirmaci√≥n final
              echo "Respuesta del Health Check:"
              curl $CURL_TARGET
              echo ""
              exit 0
            fi

            echo "Servicio no listo. C√≥digo HTTP recibido: $RESPONSE. Esperando $DELAY segundos..."
            # Muestra el estado de los contenedores si no est√° listo para ayudar en el diagn√≥stico
            docker compose ps
            sleep $DELAY
          done

          # Si el bucle termina sin √©xito, forzamos un fallo.
          echo "‚ùå ERROR: El servicio fall√≥ en arrancar despu√©s de $MAX_RETRIES intentos (150s)."
          
          # DIAGN√ìSTICO FINAL: Muestra los logs completos de todos los servicios.
          echo "--- DIAGNOSTIC INFO: √öltimos 30 logs de todos los servicios ---"
          docker compose logs --tail 30 
          echo "--- ESTADO ACTUAL DE CONTENEDORES ---"
          docker compose ps 
          echo "--- END DIAGNOSTIC INFO ---"
          
          exit 1
          
      - name: üßπ Cleanup
        run: docker compose down
        if: always()

      - name: ‚úÖ Integration Tests Confirmation
        run: echo "üß™ Pruebas de integraci√≥n completadas!"
        if: always()
