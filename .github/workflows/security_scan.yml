# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

name: üõ°Ô∏è Security & Quality Pipeline (Trivy + PHPStan + Integraci√≥n)

# Este workflow se ejecuta en push a main, Pull Requests y puede ser ejecutado manualmente (workflow_dispatch).
on:
  push:
    branches: [ "main" ]
  pull_request:
    # Las ramas a monitorizar deben ser un subconjunto de las de 'push'
    branches: [ "main" ]
  workflow_dispatch: # Permite ejecutar el workflow manualmente

# Permisos a nivel de workflow (todos los jobs)
permissions:
  contents: read

jobs:
  trivy_scan:
    # Permisos espec√≠ficos para este job (M√≠nimo Privilegio)
    permissions:
      contents: read       # Para que actions/checkout pueda obtener el c√≥digo
      security-events: write # Para que github/codeql-action/upload-sarif pueda subir los resultados SARIF
      actions: read          # Requerido para repositorios privados
      
    name: Security Scan
    runs-on: ubuntu-latest
    
    steps:
      - name: ‚¨áÔ∏è Checkout code
        uses: actions/checkout@v4

      # --- Escaneo del Front-end (FE) ---

      # Construcci√≥n de la imagen del Front-end (FE)
      - name: üèóÔ∏è Build Front-end Image (fe-web)
        # Usamos el contexto ra√≠z ('.') para acceder a 'docker/fe/Dockerfile' y 'src/fe/'
        run: docker build -t fe-web-image -f docker/fe/Dockerfile .

      - name: üîé Scan Front-end Image with Trivy
        # Usamos un hash de commit espec√≠fico para inmutabilidad
        uses: aquasecurity/trivy-action@7b7aa264d83dc58691451798b4d117d53d21edfe
        with:
          image-ref: 'fe-web-image'
          # Se usa el template SARIF est√°ndar para la integraci√≥n con GitHub Security tab
          format: 'template'
          template: '@/contrib/sarif.tpl'
          output: 'trivy-results-fe.sarif'
          # Solo reportar las vulnerabilidades m√°s graves
          severity: 'CRITICAL,HIGH'

      - name: üì§ Upload Front-end Trivy results to GitHub Security tab
        # Se usa la versi√≥n m√°s reciente v4 del uploader SARIF
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: 'trivy-results-fe.sarif'
          # Categor√≠a √önica para el Front-end
          category: 'trivy-fe-scan'

      # --- Escaneo del Task Worker (BE) ---

      # Construcci√≥n de la imagen del Worker
      - name: üèóÔ∏è Build Task Worker Image
        # Usamos el contexto ra√≠z ('.') para acceder a 'docker/worker/Dockerfile-php' y 'src/worker/'
        run: docker build -t task-worker-image -f docker/worker/Dockerfile-php .

      - name: üîé Scan Task Worker Image with Trivy
        uses: aquasecurity/trivy-action@7b7aa264d83dc58691451798b4d117d53d21edfe
        with:
          image-ref: 'task-worker-image'
          format: 'template'
          template: '@/contrib/sarif.tpl'
          output: 'trivy-results-worker.sarif'
          severity: 'CRITICAL,HIGH'

      - name: üì§ Upload Worker Trivy results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: 'trivy-results-worker.sarif'
          # Categor√≠a √önica para el Worker
          category: 'trivy-worker-scan'

      # Paso final de confirmaci√≥n
      - name: ‚úÖ Security Workflow Execution Confirmation
        run: echo "üõ°Ô∏è Security scan workflow executed successfully!"
        if: always()

  code_quality:
    name: üìè Code Quality (PHPStan)
    # Este job se ejecutar√° en paralelo con trivy_scan
    runs-on: ubuntu-latest
    
    # ‚ö†Ô∏è Nota: Este job ASUME que tiene un archivo composer.json en la ra√≠z del proyecto
    # y que PHPStan est√° configurado.

    steps:
      - name: ‚¨áÔ∏è Checkout code
        uses: actions/checkout@v4

      - name: üõ†Ô∏è Set up PHP
        # Usamos una versi√≥n similar a la del Dockerfile para consistencia
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.2'
          extensions: mbstring, pdo, pdo_pgsql, redis
          coverage: none # No necesitamos cobertura para este paso

      - name: ‚öôÔ∏è Install Composer Dependencies (PHPStan)
        # Esto instalar√° PHPStan si est√° definido como una dependencia de desarrollo en composer.json
        run: composer install --prefer-dist --no-progress --no-suggest
        # Nota: Si no tiene composer.json, este paso fallar√°.

      - name: üî¨ Run PHPStan Analysis (Level 1)
        # Hemos incrementado el nivel de 0 a 1 para una verificaci√≥n m√°s estricta
        run: ./vendor/bin/phpstan analyse src/fe src/worker --level 1 --configuration phpstan.neon
        
      - name: ‚úÖ Code Quality Confirmation
        run: echo "Code quality check with PHPStan passed!"

  integration_tests:
    name: üß™ Integration Tests (Docker Compose)
    # Este job SOLO se ejecuta si los jobs de seguridad y calidad han pasado.
    needs: [trivy_scan, code_quality]
    runs-on: ubuntu-latest
    
    steps:
      - name: ‚¨áÔ∏è Checkout code
        uses: actions/checkout@v4
      
      # Genera un archivo .env temporal usando los secrets de GitHub.
      - name: üîê Generate temporary .env file from GitHub Secrets
        run: |
          echo "POSTGRES_USER=${{ secrets.POSTGRES_USER }}" > .env
          echo "POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}" >> .env
          echo "MARIADB_ROOT_PASSWORD=${{ secrets.MARIADB_ROOT_PASSWORD }}" >> .env
          echo "POSTGRES_BI_USER=${{ secrets.POSTGRES_BI_USER }}" >> .env
          echo "POSTGRES_BI_PASSWORD=${{ secrets.POSTGRES_BI_PASSWORD }}" >> .env
          echo "Temporal .env file created for Docker Compose."
        env:
          POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          MARIADB_ROOT_PASSWORD: ${{ secrets.MARIADB_ROOT_PASSWORD }}
          POSTGRES_BI_USER: ${{ secrets.POSTGRES_BI_USER }}
          POSTGRES_BI_PASSWORD: ${{ secrets.POSTGRES_BI_PASSWORD }}


      - name: ‚¨ÜÔ∏è Start Architecture with Docker Compose
        # --wait asegura que todos los servicios est√©n 'healthy' (si est√°n configurados) o listos.
        run: docker compose up -d --build --wait

      - name: ‚è≥ Wait for services to fully initialize (Extra sleep)
        run: sleep 30s
        
      - name: üåê Run Connectivity Test (Front-end)
        # Obtenemos la IP interna del servicio 'fe-web-1' para acceder a √©l dentro de la red Docker Compose.
        run: |
          FE_CONTAINER_ID=$(docker compose ps -q fe-web-1)
          if [ -z "$FE_CONTAINER_ID" ]; then
            echo "Error: Could not find container ID for fe-web-1 service."
            exit 1
          fi
          
          FE_IP=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' "$FE_CONTAINER_ID")
          
          if [ -z "$FE_IP" ]; then
            echo "Error: Could not find IP for fe-web-1 service."
            exit 1
          fi
          
          echo "Front-end IP: $FE_IP"
          
          # Intentamos acceder al Front-end. El comando 'curl --fail' devuelve un error si el estado HTTP es >= 400.
          curl -s --fail "http://$FE_IP" -o /dev/null
          
          if [ $? -eq 0 ]; then
            echo "Connectivity test PASSED. Front-end is responding correctly."
          else
            echo "Connectivity test FAILED. Front-end is not responding or returned an error status."
            exit 1
          fi


      - name: ‚¨áÔ∏è Stop and Clean up Docker Compose
        # Ejecutar siempre, incluso si los tests fallan, para limpiar el entorno.
        if: always()
        run: docker compose down -v --remove-orphans

      - name: ‚úÖ Integration Tests Confirmation
        run: echo "üß™ Todos los tests de integraci√≥n han pasado exitosamente."
